
hello markdown

# Creating a window for Direct3D11 using the WindowsOS
Admittedly, dealing with the old WindowsOS windowing system is my least favorite part about DirectX. It isn't really ally that bad, it just looks strange. I'm going run through it fairly quickly, only hitting on the relevant points. If you're curious and want more info, Microsoft has a plethora of doc pages. You can find them easily by googling "msdn thing-I-want-to-know-about". Now I've tried my best to break these concepts down, but the concepts are rather circular.
Here's the basic concepts
* windowOS applications have a special `main` method
* windowOS windows have an event system where events are named `messages`.
* your appliation must write a function to `handle` these "message" events.

The main method for WindowsAPI looks a bit different from our normal c++ `int main()`. Check out the commented version. 
```cpp
int WINAPI WinMain(
    HINSTANCE hInstance,        //a handle an instance of our application
    HINSTANCE hPrevInstance,    //legacy argument that's always null
    LPSTR pCmdLine,             //a long pointer to our command line arguments (eg "OurGame.exe -these -are -cmd -line -args")
    int nShowCmd                //mostly legacy, we'll ignore it. It will be one of the ShowWindow argument's prefixed with SW_
    )
{
        //...application code processing messages and drawing with direct3d...
	return message_WM_QUIT.wparam;
}
```
So, there's a few curious things here.
* Firstly, `WINAPI` is a `calling convention`; it is irrelevant to our purposes here. If you're curious, the calling convention specifies how the c++/c function callstack pushes/pops function arguments. 
* Secondly, notice that `WinMain` returns the wparam of a quit message. This quit message is one of those window's events; we'll get to that shortly.
* Thirdly, Most of the arguments to the main method can be ignored. But we will need the `hInstance` for our window creation. 

If you want to know more, check out the documentation by googling [WinMan MSDN](https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-winmain)

The WindowsAPI requires that we write an event handler. This event handler will process the `message` events generated by our application. This event handling function is called a `WindowProcedure`; commonly abbreviated as `WndProc`. 
Take a look at this one, don't be alarmed if it looks a little alien to normal c++.
```cpp
/** WINDOWS: A window instance's callback to handle events; WindowsOS will call this sometime after we call "DispatchMessage"*/
LRESULT CALLBACK WndProc_MessageHandler(
        HWND hWnd,      // handle to the window where the message originated
        UINT msg,       // an message event id; many of these are defined in WinUser.h (eg WM_KEYDOWN)
        WPARAM wParam,  // extra information associated with this message
        LPARAM lParam   // even more information associated with this message
    )
{
    switch (msg)
    {
        case WM_KEYDOWN:
            if (wParam == VK_ESCAPE) { DestroyWindow(hWnd); }
            return 0;
        case WM_DESTROY:
            PostQuitMessage(0);
            return 0;
    }
    return DefWindowProc(hWnd, msg, wParam, lParam);    //unhandled events should be processed by the default window procedure
}
```
The `WmdProc` return value depends on the message that is handled; most of time we `return 0` to signal everything went okay. `CALLBACK` is another calling convention (recall the `WINAPI` calling convetion?). [For the curious: it appears both `WINAPI` and `CALLBACK` are the same calling convention as they are macros defined as `__stdcall`]. Notice we create a switch around the `msg` event. When we handle the window message keydown (`WM_KEYDOWN`) we determine what key is pressed by `wParam` argument. The information provided in the `wParam` changes depending on the type of message being handled. What's in `lParam` also changes depending on the message. For example the `lParam` contains bits specifying a key's scanCode and repeat count for the `WM_KEYDOWN`, but for the `WM_MOUSEMOVE` the `lParam` contains the x and y position of the mouse bit-packed together.


START HERE START HERE START HERE START HERE ^^^^^^^^^^^^^^^^^^



At a high level, you instruct your WindowsOS that you would like to create a window of a certain "class". This "class" isn't quite the same definition of class you see in traditional object oriented programming languages like c++, c#, or java. Instead we fill out a `struct WNDCLASS` Let's first preview the code before we talk about it.

```cpp
const wchar_t* WindowClassName = L"MyWidowClass";

WNDCLASS windowClass;
windowClass.lpfnWndProc = &WndProc_MessageHandler;//winproc callback handles events
windowClass.style = CS_HREDRAW | CS_VREDRAW | CS_OWNDC;//class styles (CS) specify drawing when size changes
windowClass.cbClsExtra = 0;//extra memory slot; we're not going to use
windowClass.cbWndExtra = 0;//extra memory slot; we're not going to use
windowClass.hInstance = hInstance;//gives the class a pointer to the main application object
windowClass.hIcon = LoadIcon(0, IDI_APPLICATION);//creates a default icon
windowClass.hCursor = LoadCursor(0, IDC_ARROW);//creates the default cursor
windowClass.hbrBackground = static_cast<HBRUSH>(GetStockObject(WHITE_BRUSH));//makes the background white
windowClass.lpszMenuName = 0; //we don't have a menu pop up
windowClass.lpszClassName = WindowClassName; //a string identifier to find this wc struct at creation

if (!RegisterClass(&windowClass))
{
    MessageBox(0, L"Failed to register window class", 0, 0); //MessageBox is a small popup with text
    return 0;
}
```
There's a lot going on here; most of it is irrelevant right now. I've added trailing comments to give a brief description of what each field does. Check the [WNDCLASS MSDN page](https://docs.microsoft.com/en-us/previous-versions/ms942860(v%3Dmsdn.10)) for more info on what I don't cover about `struct WNDCLASS`.

`WNDCLASS::lpfnWndProc` is a (`l`ong `p`ointer) `f`u`n`ction pointer. We assign it a pointer to a function define to handle window events; this function is called the `WindowProcedure`.


# Creating a window for OpenGL using the GLFW library



## references
http://keithditch.powweb.com/Games/html/wndproc.html